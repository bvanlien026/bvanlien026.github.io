<!DOCTYPE html>
<link href="/styles/style.css" rel="stylesheet" />
<html>
<head>
    <meta charset="UTF-8">
    <title>Benji Van Lienden - CS 180 Project 3</title>
    <link href="./styles/style.css" rel="stylesheet" />
    <script>
        window.MathJax = {
            tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
</head>
<body>
    <div class="header">
        <h1>Project 3: (Auto)stitching and Photo Mosaics</h1>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>About This Project</h2>
        <p>
            In Part A of this project, our goal is to create an algorithm that,
            given two images and a set of point correspondences between the images, will
            warp one image so that it has the same perspective as the second image.
            Then, we can align the two images to create a mosaic.
        </p>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part A.1: Shoot the Pictures</h2>
        <p>
            The first set of photos I took was of a kitchen, with the refrigerator at the center:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_2_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_3_resized.jpg">
            </div>
        </div>
        <p>
            Next, I took photos of Hearst Mining Circle as seen from the 9th floor of Evans Hall:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/hearst/hearst_left_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_middle_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_right_resized.jpg">
            </div>
        </div>
        <p>
            Finally, I took photos of a bridge near Haviland Hall:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/bridge/bridge_left_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/bridge/bridge_middle_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/bridge/bridge_right_resized.jpg">
            </div>
        </div>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part A.2: Recover Homographies</h2>
        <p>
            To warp one image into alignment with another image, we compute the homography $H$,
            the transformation between the points of the images. $H$ is a 3x3 matrix given by
            $$
            H = \begin{bmatrix}
                a & b & c \\
                d & e & f \\
                g & h & 1
            \end{bmatrix}
            $$
            and relates the points of two images by $p' = Hp$. To compute the entries of $H$,
            we can put them into a vector
            $$
            h = [a, b, c, d, e, f, g, h]^\top
            $$
            and set up a system of equations $Ah = b$. If we have $n$ points $p = (x_i, y_i)$ of one
            image corresponding to $p' = (u_i, v_i)$ of another image, then our system will look like
            $$
            \begin{bmatrix}
                u_1 \\ v_1 \\ u_2 \\ v_2 \\ \vdots \\ u_n \\ v_n
            \end{bmatrix} = \begin{bmatrix}
                x_1 & y_1 & 1 & 0 & 0 & 0 & -u_1x_1 & -u_1y_1 \\
                0 & 0 & 0 & x_1 & y_1 & 1 & -v_1x_1 & -v_1y_1 \\
                x_2 & y_2 & 1 & 0 & 0 & 0 & -u_2x_2 & -u_2y_2 \\
                0 & 0 & 0 & x_2 & y_2 & 1 & -v_2x_2 & -v_2y_2 \\
                \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
                x_n & y_n & 1 & 0 & 0 & 0 & -u_nx_n & -u_ny_n \\
                0 & 0 & 0 & x_n & y_n & 1 & -v_nx_n & -v_ny_n
            \end{bmatrix} \begin{bmatrix}
                a \\ b \\ c \\ d \\ e \\ f \\ g \\ h
            \end{bmatrix}
            $$
            and we can solve it using least squares.
        </p>
        <p>
            To actually implement this with two images, first we need to mark correspondences
            between the two images. Doing this manually for some of the above images,
            we get the following:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_correspondences.jpg">
                <p>Kitchen Image 1 Points</p>
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_2_correspondences.jpg">
                <p>Kitchen Image 2 Points</p>
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_left_correspondences.jpg">
                <p>Hearst Mining Circle Image 1 Points</p>
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_middle_correspondences.jpg">
                <p>Hearst Mining Circle Image 2 Points</p>
            </div>
        </div>
        <p>
            The homologies corresponding to these correspondences are
            $$
            H_\text{kitchen} = \begin{bmatrix}
                1.83052621e+00 & 4.76249658e-02 & -3.51938539e+02 \\
                4.94162924e-01 & 1.51133695e+00 & -2.37072711e+02 \\
                1.06390846e-03 & 3.90405294e-05 & 1.00000000e+00
            \end{bmatrix}
            $$
            and
            $$
            H_\text{hearst} = \begin{bmatrix}
                1.35804523e+00 & 4.48875970e-02 & -3.64647562e+02 \\
                2.05880819e-01 & 1.21072234e+00 & -7.52359006e+01 \\
                4.96702491e-04 & -3.37418688e-05 & 1.00000000e+00
            \end{bmatrix}
            $$
        </p>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part A.3: Warp the Images</h2>
        <p>
            Now that we have computed homographies for our images, we want to use them
            to warp the images into alignment. To do this, we implement inverse warping
            combined with either Nearest Neighbor Interpolation and Bilinear Interpolation.
        </p>
        <p>
            We use inverse warping to avoid holes appearing in the output image. The idea is
            that instead of directly applying $H$ in the formula $p' = Hp$, we instead take its
            inverse and use the formula $H^{-1}p' = p$. For each point in the output image,
            we apply $H^{-1}$ to get a point from the input image. Since the point we land on
            in the input image may not be a whole number, we use interpolation to choose a value.
        </p>
        <p>
            For Nearest Neighbor Interpolation, we round the point we land on to the nearest
            whole number on both the $x$ and $y$ axes. Then, we take the pixel value at the
            rounded pixel position and copy it to the output image.
        </p>
        <p>
            For Bilinear Interpolation, we take a weighted average of the four pixels
            around the pixel we land on. To do this, we compute the values of the four pixels,
            compute the areas between the landing point and each neighboring pixel, and multiply
            the values with their corresponding areas. Then we sum up all these products and
            copy the resulting value to the output image.
        </p>
        <p>
            In addition to this, I also computed the warped locations of the image corners
            and used them to find the maximum size of the warped image, so that the entire image
            could be displayed on the output.
        </p>
        <p>
            To test my functions, I performed rectification on some images by warping a photo
            of rectangular objects to make them rectangular in the image.
        </p>
        <p>
            First, I mapped a Berkeley Statistics sign in Evans Hall to a 300x300 square:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/berkeley_stats/berkeley_stats_compressed.jpg">
                <p>Original</p>
            </div>
            <div class="image-item">
                <img src="./media/berkeley_stats/nearest_neighber_cropped.jpg">
                <p>Nearest Neighbor (Cropped)</p>
            </div>
            <div class="image-item">
                <img src="./media/berkeley_stats/bilinear_cropped.jpg">
                <p>Bilinear (Cropped)</p>
            </div>
        </div>
        <p>
            Next, I mapped some sea animal pictures on my wall to a 340x440 rectangle:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/sea_animals/sea_animals.jpg">
                <p>Original</p>
            </div>
            <div class="image-item">
                <img src="./media/sea_animals/nearest_neighbor_cropped.jpg">
                <p>Nearest Neighbor (Cropped)</p>
            </div>
            <div class="image-item">
                <img src="./media/sea_animals/bilinear_cropped.jpg">
                <p>Bilinear (Cropped)</p>
            </div>
        </div>
        <p>
            Bilinear Interpolation seemed to produce marginally better results than
            Nearest Neighbor Interpolation, and both of my implementations seemed to run
            pretty slowly on larger images.
        </p>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part A.4: Blend the Images into a Mosaic</h2>
        <p>
            Finally, with our images warped, we can align and blend them into a mosaic. First, I
            modified and used code from Project 2 to align the images. Then, I drew a mask for each
            pair of images and used laplacian stacks with just 2 layers to blend the images.
            I got the following results:

        </p>
        <p style="text-align: center;">
            Kitchen Images Separated
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_2_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_3_resized.jpg">
            </div>
        </div>
        <p style="text-align: center;">
            Kitchen Mosaic
        </p>
        <img src="./media/kitchen/kitchen_123.jpg">
        <p style="text-align: center;">
            Hearst Mining Circle Images Separated
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/hearst/hearst_left_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_middle_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_right_resized.jpg">
            </div>
        </div>
        <p style="text-align: center;">
            Hearst Mining Circle Mosaic
        </p>
        <img src="./media/hearst/hearst.jpg">
        <p style="text-align: center;">
            Bridge Images Separated
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/bridge/bridge_left_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/bridge/bridge_middle_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/bridge/bridge_right_resized.jpg">
            </div>
        </div>
        <p style="text-align: center;">
            Bridge Mosaic
        </p>
        <img src="./media/bridge/bridge.jpg">
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part B.1: Harris Corner Detection</h2>
        <p>
            The first step to automate the alignment from above is to automatically detect
            corners in the image. The idea here is that for any point on the image, that point
            is a corner if translating a small region around the point in any direction causes
            a significant change in all directions. The basic function is defined for us in
            <code>harris.py</code>.
        </p>
        <p>
            We also want to implement Adaptive Non-Maximal Suppression. The idea here is to get
            corners that are more spread out throughout the image. This works by sorting the points
            by corner strength and then only taking corners within a certain radius of the
            stronger corners. Implementing ANMS on the kitchen images gives the following:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_harris_corners_no_anms.jpg">
                <p>Without ANMS</p>
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_harris_corners_anms.jpg">
                <p>With ANMS</p>
            </div>
        </div>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part B.2: Feature Descriptor Extraction</h2>
        <p>
            Next, we want to sample the features around each corner so that we can match them
            between images later. To do this, we sample an 8x8 patch from a 40x40 window around
            each corner, where each pixel in the 8x8 patch is 5 pixels apart in the 40x40 window.
            Running this on the corners detected in the kitchen image, we get the following
            feature descriptors (40 shown of the 75 computed):
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_descs.png">
            </div>
        </div>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part B.3: Feature Matching</h2>
        <p>
            Now we have two sets of feature descriptors, one for each image, and we want to use
            them to match corners that look similar to each other. To do this, we first take the
            Euclidean distance between each pair of points. THen for each point, we compute the
            ratio of the distance from the first nearest neighbor and the distance from the second
            nearest neighbor. If the ratio is less than 0.8, we keep that point and its nearest
            neighbor as a match.
        </p>
        <p>
            If we use the above to match points between two images we want to warp into
            alignment, we get the following correspondences:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_12_correspondences.jpg">
            </div>
        </div>
    </div>
    &nbsp;
    <div class="part-box">
        <h2>Part B.4: RANSAC for Robust Homography</h2>
        <p>
            Not all the correspondences found were correct. However, we can assume that the
            correct correspondences will have the most inliers, meaning that a homography
            will warp all of those points into the correct position. To find the inliers, we
            use RANSAC. to do this, we select four feature pairs randomly, compute a homography
            $H$ between them, and then compute the number of point pairs $(p, p^*)$ such that
            $\text{dist}(p^*, Hp) < \varepsilon$ for some threshold $\varepsilon$. Doing this
            many times, the inliers are the largest set of points for which
            $\text{dist}(p^*, Hp) < \varepsilon$.
        </p>
        <p>
            Running RANSAC on our matches and plotting only the inliers, we get:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_12_inliers.jpg">
            </div>
        </div>
        <p>
            Finally, we can use least squares on the set of inliers to compute a homography
            which we use to warp the images:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_1_warped_ransac.jpg">
                <p>Image 1, Warped with RANSAC</p>
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_2_resized.jpg">
                <p>Image 2</p>
            </div>
        </div>
        <p>
            At this point, to automatically align the images, I just tracked two inliers
            through the warping process and used the adapted code from Project 2 to align the
            images. I then used averaging to blend the images automatically. This caused more
            artifacting than the method I used before, but with the tradeoff that I was able to
            do it automatically instead of through a 10-minute manual process. Below are the
            results:
        </p>
        <p>
            First, the kitchen:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/kitchen/kitchen_123.jpg">
                <p>Manual</p>
            </div>
            <div class="image-item">
                <img src="./media/kitchen/kitchen_123_auto.jpg">
                <p>Automatic</p>
            </div>
        </div>
        <p>
            Next, Hearst Mining Circle:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/hearst/hearst.jpg">
                <p>Manual</p>
            </div>
            <div class="image-item">
                <img src="./media/hearst/hearst_auto.jpg">
                <p>Automatic</p>
            </div>
        </div>
        <p>
            I couldn't get all the bridge images to warp because the Harris corner detector couldn't
            detect enough corners. I suspect this is because there is a lot of noise in the trees
            and bushes. Instead, I only aligned two of the images:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/bridge/bridge_auto.jpg">
            </div>
        </div>
        <p>
            I also took some photos of the campanile and automatically blended them:
        </p>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/campanile/campanile_bottom_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/campanile/campanile_middle_resized.jpg">
            </div>
            <div class="image-item">
                <img src="./media/campanile/campanile_top_resized.jpg">
            </div>
        </div>
        <div class="image-row">
            <div class="image-item">
                <img src="./media/campanile/campanile_auto.jpg">
            </div>
        </div>
    </div>
</body>
</html>
